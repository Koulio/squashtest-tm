<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) 2010 - 2012 Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">

	<!--  DO NOT FORGET TO UPDATE VERSION IN CORE_CONFIG ! -->
	<changeSet id="tm-1.3.0.01" author="gfouquet">
		<comment>Adds a TM database version number</comment>
		<update tableName="CORE_CONFIG">
			<column name="STR_KEY" value="squashtest.tm.database.version" />
			<column name="VALUE" value="1.3.0" />
			<where>STR_KEY = 'squashtest.tm.database.version'</where>
		</update>
	</changeSet>


	<changeSet id="tm-1.3.0.2" author="gfouquet">
		<comment>
			Add a default group to users who do not have one (should be users from alpha versions)
		</comment>
		<sql>
			create temporary table GROUPLESS_USERS (USER_ID INTEGER);
			
			insert into GROUPLESS_USERS (USER_ID)
			select cu.ID from CORE_USER cu
			where cu.ID not in (select cgm.USER_ID from CORE_GROUP_MEMBER cgm);
			
			insert into CORE_GROUP_MEMBER (USER_ID, GROUP_ID)
			select cu.ID, cg.ID
			from CORE_USER cu, CORE_GROUP cg
			where cg.QUALIFIED_NAME = 'squashtest.tm.group.User'
			and cu.ID in (select USER_ID from GROUPLESS_USERS);
		</sql>
	</changeSet>
	
	<!--  ==================================
				Feat. 1112
	======================================== -->
	
	
	<changeSet id="tm-1.3-feat-1112.0" author="bsiri">
		<comment>
			The following serie of changeset labelled tm-1.3-feat-1112.x implements the closure table
			modelization for tree-like data	at 
			http://www.mysqlperformanceblog.com/2011/02/14/moving-subtrees-in-closure-table/, 
			with a focus on the mysql-specifics shortcomings regarding modifying a table already
			under modification. 
			
			Big kudos to you Bill Karwin ! 
		</comment>
	
	</changeSet>
	

	
	<changeSet id="tm-1.3-feat-1112.01" author="bsiri">
	
		<comment>
			closure table for test case library nodes. TODO: list the triggers that will populate it.
		</comment>
		
		<createTable tableName="TCLN_RELATIONSHIP_CLOSURE">
			<column name="ANCESTOR_ID" type="BIGINT"
			remarks="cle etrangere vers le noeud parent. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false"
				foreignKeyName="fk_tcln_relationship_clos_anc"
				references="TEST_CASE_LIBRARY_NODE(TCLN_ID)"/>	
			</column> 	
	
			<column name="DESCENDANT_ID" type="BIGINT"
				remarks="cle etrangere vers l'element fils. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false" 
				foreignKeyName="fk_tcln_relationship_clos_desc"
				references="TEST_CASE_LIBRARY_NODE(TCLN_ID)"/>		
			</column>
			
			<column name="DEPTH" type="java.sql.Types.TINYINT"
				remarks="stores how deep is the descendant element nested in the subtree of the ancestor element"
				<constraints nullable="false"/>
			</column>
		</createTable>	
		
	
		<createIndex tableName="TCLN_RELATIONSHIP_CLOSURE" indexName="idx_tcln_relationship_clos_desc">
		    <column name="DESCENDANT_ID"/>
		</createIndex>
		
		<createIndex tableName="TCLN_RELATIONSHIP_CLOSURE" indexName="idx_tcln_relationship_clos_anc">
		    <column name="ANCESTOR_ID"/>
		</createIndex>
	</changeSet>
		
	
	<changeSet id="tm-1.3-feat-1112.02" author="bsiri">
	
		<comment>
			closure table for requirement library nodes
		</comment>
		
		<createTable tableName="RLN_RELATIONSHIP_CLOSURE">
			<column name="ANCESTOR_ID" type="BIGINT"
			remarks="cle etrangere vers le noeud parent. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false"
				foreignKeyName="fk_rln_relationship_clos_anc"
				references="REQUIREMENT_LIBRARY_NODE(RLN_ID)"/>	
			</column> 	
	
			<column name="DESCENDANT_ID" type="BIGINT"
				remarks="cle etrangere vers l'element fils. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false" 
				foreignKeyName="fk_rln_relationship_clos_desc"
				references="REQUIREMENT_LIBRARY_NODE(RLN_ID)"/>		
			</column>
			
			<column name="DEPTH" type="java.sql.Types.TINYINT"
				remarks="stores how deep is the descendant element nested in the subtree of the ancestor element"
				<constraints nullable="false"/>
			</column>
		</createTable>	
		
	
		<createIndex tableName="RLN_RELATIONSHIP_CLOSURE" indexName="idx_rln_relationship_clos_desc">
		    <column name="DESCENDANT_ID"/>
		</createIndex>
		
		<createIndex tableName="RLN_RELATIONSHIP_CLOSURE" indexName="idx_rln_relationship_clos_anc">
		    <column name="ANCESTOR_ID"/>
		</createIndex>
	</changeSet>
			
		
		
	
	<changeSet id="tm-1.3-feat-1112.03" author="bsiri">
	
		<comment>
			closure table for campaign library nodes.
		</comment>
		
		<createTable tableName="CLN_RELATIONSHIP_CLOSURE">
			
			<column name="ANCESTOR_ID" type="BIGINT"
			remarks="cle etrangere vers le noeud parent. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false"
				foreignKeyName="fk_cln_relationship_clos_anc"
				references="CAMPAIGN_LIBRARY_NODE(CLN_ID)"/>	
			</column> 	
	
			<column name="DESCENDANT_ID" type="BIGINT"
				remarks="cle etrangere vers l'element fils. La relation est parfois d'un noeud vers lui meme.">
				<constraints nullable="false" 
				foreignKeyName="fk_cln_relationship_clos_desc"
				references="CAMPAIGN_LIBRARY_NODE(CLN_ID)"/>		
			</column>
			
			
			<column name="DEPTH" type="java.sql.Types.TINYINT"
				remarks="stores how deep is the descendant element nested in the subtree of the ancestor element"
				<constraints nullable="false"/>
			</column>
		</createTable>	
		
	
		<createIndex tableName="CLN_RELATIONSHIP_CLOSURE" indexName="idx_cln_relationship_clos_desc">
		    <column name="DESCENDANT_ID"/>
		</createIndex>
		
		<createIndex tableName="CLN_RELATIONSHIP_CLOSURE" indexName="idx_cln_relationship_clos_anc">
		    <column name="ANCESTOR_ID"/>
		</createIndex>
	</changeSet>
	
	
	<changeSet id="tm-1.3-feat-1112.04" author="bsiri">
		<comment>
			first step of the migration : creation of temporary tables in which we will dump 
			the X_RELATIONSHIP tables, then truncate the later. We will reinsert the data once 
			the triggers are all set.
		</comment>
		
	
		<createTable tableName="TCLN_RELATIONSHIP_TMP">			
			<column name="ANCESTOR_ID" type="BIGINT" />	
			<column name="DESCENDANT_ID" type="BIGINT" />
		</createTable>	
	
		<createTable tableName="RLN_RELATIONSHIP_TMP">			
			<column name="ANCESTOR_ID" type="BIGINT" />	
			<column name="DESCENDANT_ID" type="BIGINT" />
		</createTable>
	
		<createTable tableName="CLN_RELATIONSHIP_TMP">			
			<column name="ANCESTOR_ID" type="BIGINT" />	
			<column name="DESCENDANT_ID" type="BIGINT" />
		</createTable>
					
		<sql>
			insert into TCLN_RELATIONSHIP_TMP
				select * from TCLN_RELATIONSHIP
		</sql>			
		
		<sql>
			insert into RLN_RELATIONSHIP_TMP
				select * from RLN_RELATIONSHIP
		</sql>	

		<sql>
			insert into CLN_RELATIONSHIP_TMP
				select * from CLN_RELATIONSHIP
		</sql>	
		
		<sql>delete from TCLN_RELATIONSHIP</sql>
		<sql>delete from RLN_RELATIONSHIP</sql>
		<sql>delete from CLN_RELATIONSHIP</sql>
	
	</changeSet>
		
		
<!-- 
	TODO : put the following in the right place :


-- after insertion of a tcl node
create trigger ins_tcln_after after insert on TEST_CASE_LIBRARY_NODE
for each row insert into TCLN_RELATIONSHIP_CLOSURE values (new.tcln_id, new.tcln_id, 0);


-- before suppression of a tcl node
create trigger del_tcln_after before delete on TEST_CASE_LIBRARY_NODE
for each row delete from TCLN_RELATIONSHIP_CLOSURE where ancestor_id=old.tcln_id and descendant_id=ancestor_id;


-- when association of tcl node is created
create trigger attach_tcln after insert on TCLN_RELATIONSHIP
for each row insert into TCLN_RELATIONSHIP_CLOSURE 
		select c1.ancestor_id, c2.descendant_id, c1.depth+c2.depth+1
		from TCLN_RELATIONSHIP_CLOSURE c1
		cross join TCLN_RELATIONSHIP_CLOSURE c2
		where c1.descendant_id = new.ancestor_id
		and c2.ancestor_id = new.descendant_id;
		

-- when association of tcl nodes are removed
create trigger detach_tcln before delete on TCLN_RELATIONSHIP
for each row delete clos1 from TCLN_RELATIONSHIP_CLOSURE clos1 
		join TCLN_RELATIONSHIP_CLOSURE clos2 
			on clos1.descendant_id=clos2.descendant_id
		left join TCLN_RELATIONSHIP_CLOSURE clos3 
			on clos3.ancestor_id = clos2.ancestor_id 
			and clos3.descendant_id = clos1.ancestor_id
		where clos2.ancestor_id = old.descendant_id 
		and clos3.ancestor_id is null;

 -->
	
</databaseChangeLog>
 