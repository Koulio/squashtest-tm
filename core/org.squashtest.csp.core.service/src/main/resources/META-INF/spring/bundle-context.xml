<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) 2010 - 2011 Squashtest TM, Squashtest.org

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:util="http://www.springframework.org/schema/util" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
  	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd
	http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
	http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.xsd">

	<context:component-scan base-package="*" />

	<!-- ====== BEAN VALIDATION ====== -->
	<bean id="javax.validation.ValidatorFactory" class="org.squashtest.csp.core.validation.ValidatorFactoryBean"
		factory-method="getInstance" />

	<!-- ====== SECURITY PLUMBING ====== -->
	<bean class="org.springframework.security.acls.AclPermissionEvaluator" id="squashtest.core.security.PermissionEvaluator">
		<constructor-arg ref="squashtest.core.security.AclService" />
		<property name="objectIdentityRetrievalStrategy" ref="squashtest.core.security.ObjectIdentityRetrievalStrategy" />
		<property name="objectIdentityGenerator" ref="squashtest.core.security.ObjectIdentityGeneratorStrategy" />
	</bean>

	<bean class="org.squashtest.csp.core.security.acls.jdbc.JdbcManageableAclService" id="squashtest.core.security.AclService">
		<constructor-arg ref="squashtest.core.persistence.jdbc.DataSource" />
		<constructor-arg ref="lookupStrategy" />
		
		<property name="aclCache" ref="aclCache" /> <!--  about that heresy, see comments in JdbcManageableAclService sources -->
		
		<property name="findChildrenQuery">
			<value>
				select null as obj_id,
				null as class
				from ACL_OBJECT_IDENTITY
				where 0 = 1
			</value>
		</property>
	</bean>

	<bean id="lookupStrategy" class="org.springframework.security.acls.jdbc.BasicLookupStrategy">
		<constructor-arg ref="squashtest.core.persistence.jdbc.DataSource" />
		<constructor-arg ref="aclCache" />
		<constructor-arg ref="aclAuthzStrategy" />
		<constructor-arg ref="aclAuditLogger" />
		<property name="selectClause">
			<value>
				select oid.IDENTITY as object_id_identity,
				gp.PERMISSION_ORDER,
				oid.ID as acl_id,
				null as parent_object, /* oid.parent */
				true as entries_inheriting, /* oid.entries_inheriting*/
				rse.ID as ace_id,
				gp.PERMISSION_MASK as mask,
				gp.GRANTING as granting,
				true as audit_success, /* audit success */
				false as audit_failure, /* audit failure */
				true as ace_principal, /* sid is principal */
				u.LOGIN as ace_sid,
				true as acl_principal, /* owner is prinipal */
				u.LOGIN as acl_sid, /* owner sid */
				ocl.CLASSNAME as class
				from ACL_OBJECT_IDENTITY oid
				left join ACL_CLASS ocl on ocl.ID = oid.CLASS_ID
				left join ACL_GROUP_PERMISSION gp on gp.CLASS_ID = ocl.ID
				left join ACL_GROUP g on g.ID = gp.ACL_GROUP_ID
				left join ACL_RESPONSIBILITY_SCOPE_ENTRY rse on rse.ACL_GROUP_ID = g.ID and rse.OBJECT_IDENTITY_ID = oid.ID
				inner join CORE_USER u on u.ID = rse.USER_ID
				where (
			</value>
		</property>
		<property name="lookupObjectIdentitiesWhereClause">
			<value>(oid.IDENTITY = ? and ocl.CLASSNAME = ?)</value>
		</property>
		<property name="lookupPrimaryKeysWhereClause">
			<value>(oid.ID = ?)</value>
		</property>
		<property name="orderByClause">
			<value>) order by oid.IDENTITY asc, gp.PERMISSION_ORDER asc</value>
		</property>
	</bean>

	<bean id="aclAuthzStrategy" class="org.springframework.security.acls.domain.AclAuthorizationStrategyImpl">
		<constructor-arg>
			<list>
				<ref local="aclAdminAuthority" />
				<ref local="aclAdminAuthority" />
				<ref local="aclAdminAuthority" />
			</list>
		</constructor-arg>
	</bean>

	<bean id="aclAdminAuthority" class="org.springframework.security.core.authority.GrantedAuthorityImpl">
		<constructor-arg value="ROLE_ADMIN" />
	</bean>

	<!-- TODO replace by ehcache -->
	<!-- bean id="aclCache" class="org.squashtest.csp.core.security.acls.model.NullAclCache" / -->
	<bean id="aclAuditLogger" class="org.squashtest.csp.core.security.acls.Slf4jAuditLogger" />

	<bean id="permissionFactory" class="org.springframework.security.acls.domain.DefaultPermissionFactory" />

	<bean id="ehCacheManagerBean" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" />

	<bean id="ehCacheFactoryBean" class="org.springframework.cache.ehcache.EhCacheFactoryBean">
		<property name="cacheManager" ref="ehCacheManagerBean" />
		<property name="overflowToDisk" value="false" />
		<property name="timeToIdle" value="600" />
		<property name="timeToLive" value="1800" />
	</bean>

	<bean class="org.springframework.security.acls.domain.EhCacheBasedAclCache" id="aclCache">
		<constructor-arg ref="ehCacheFactoryBean" />
	</bean>

	<!-- the following bean, exposed through OSGI, we'll be in charge of modifications of the user auth. note that the password 
		encoder should be consistent with the one used in the authentication. Needs the userDetailsManager defined below. -->
	<bean id="squashtest.core.security.AdministratorAuthenticationService" class="org.squashtest.csp.core.internal.security.security.AdministratorAuthenticationServiceImpl">
		<property name="passwordEncoder">
			<bean class="org.springframework.security.authentication.encoding.ShaPasswordEncoder" />
		</property>
		<property name="userDetailsManager" ref="squashtest.core.security.JdbcUserDetailsManager" />
	</bean>

	
	 <!-- 
		* The following bean provide a link to the credentials, both reading and editing. 
		todo : create a bean configurable via a .properties file, in case we need to switch 
		to an LDAP provider. 
		
		* Another trick happening here : the authenticationManager is defined core.web side. So we cant inject it there 
		unless we expose it through OSGI, which would be cumbersome.
		So we'll let a bean consuming this service in the core.web bundle set the property.	  
		
	  -->
	
	<bean id="squashtest.core.security.JdbcUserDetailsManager"
			class="org.springframework.security.provisioning.JdbcUserDetailsManager">
		
		<property name="dataSource" ref="squashtest.core.persistence.jdbc.DataSource"/>
		
		<!--
			see the comment above 
			<property name="authenticationManager" ref="squashtest.core.security.AuthenticationManager"/>
		-->
		
		<property name="usersByUsernameQuery" value="select LOGIN, PASSWORD, ACTIVE from AUTH_USER where LOGIN = ?"/>
		
		<property name="groupAuthoritiesByUsernameQuery">
			<value>
				select g.ID, g.QUALIFIED_NAME, ga.AUTHORITY 
				from CORE_GROUP g 
					inner join CORE_GROUP_AUTHORITY ga on ga.GROUP_ID = g.ID
					inner join CORE_GROUP_MEMBER gm on gm.GROUP_ID = g.ID
					inner join CORE_USER u on u.ID = gm.USER_ID
				where u.LOGIN = ?		
			</value>
		</property>	
		
		<!--  dummy query, see explanation below -->
		<property name="authoritiesByUsernameQuery" value="select login, 'ROLE_USER' from CORE_USER where login = ?">
		
		</property>
		
		
		<property name="changePasswordSql">
			<value>
				update AUTH_USER
				set PASSWORD = ?
				where LOGIN = ?
			</value>
		</property>
		
		<property name="createUserSql">
			<value>
				insert into AUTH_USER (LOGIN, PASSWORD, ACTIVE) values (?,?,?)
			</value>
		</property>
		
		<!--  
			A successful login attempt requires the user to have at least one authority set (and also a valid login/pass).
			
			Our policy regarding authorities is group-based : there are no per-user authorities and they 
			must be attached to a group.
			
			However due to the restriction mentioned above (about successful login),  we want the user to be granted 
			a default authority if he doesn't belong to a group yet. That authority can merely allow him to 
			connect to the application, but without proper entry in acls he couldn't do much anyway.
			
			So we fetch both personal authorities for the default one, and the group authorities for the real ones. 
			
		-->		
		<property name="enableAuthorities" value="true"/>
		<property name="enableGroups" value="true" />
		
	</bean>
	
	
	
	
</beans>

